// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: matches.sql

package sqlc

import (
	"context"
	"strings"
)

const addMatch = `-- name: AddMatch :exec
INSERT INTO matches (
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    event_id,
    scheduled_at,
    created_at,
    created_by,
    updated_at,
    updated_by
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10,
    ?11,
    ?12
)
`

type AddMatchParams struct {
	GuildID             string `db:"guild_id"`
	ChannelID           string `db:"channel_id"`
	ChannelAccessibleAt int64  `db:"channel_accessible_at"`
	ChannelAccessible   int64  `db:"channel_accessible"`
	ChannelDeleteAt     int64  `db:"channel_delete_at"`
	MessageID           string `db:"message_id"`
	EventID             string `db:"event_id"`
	ScheduledAt         int64  `db:"scheduled_at"`
	CreatedAt           int64  `db:"created_at"`
	CreatedBy           string `db:"created_by"`
	UpdatedAt           int64  `db:"updated_at"`
	UpdatedBy           string `db:"updated_by"`
}

func (q *Queries) AddMatch(ctx context.Context, arg AddMatchParams) error {
	_, err := q.exec(ctx, q.addMatchStmt, addMatch,
		arg.GuildID,
		arg.ChannelID,
		arg.ChannelAccessibleAt,
		arg.ChannelAccessible,
		arg.ChannelDeleteAt,
		arg.MessageID,
		arg.EventID,
		arg.ScheduledAt,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	return err
}

const countMatches = `-- name: CountMatches :one
SELECT COUNT(channel_id) AS count
FROM matches
WHERE guild_id = ?1
`

func (q *Queries) CountMatches(ctx context.Context, guildID string) (int64, error) {
	row := q.queryRow(ctx, q.countMatchesStmt, countMatches, guildID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteGuildMatches = `-- name: DeleteGuildMatches :exec
DELETE FROM matches WHERE guild_id = ?1
`

func (q *Queries) DeleteGuildMatches(ctx context.Context, guildID string) error {
	_, err := q.exec(ctx, q.deleteGuildMatchesStmt, deleteGuildMatches, guildID)
	return err
}

const deleteMatch = `-- name: DeleteMatch :exec
DELETE FROM matches WHERE channel_id = ?1
`

func (q *Queries) DeleteMatch(ctx context.Context, channelID string) error {
	_, err := q.exec(ctx, q.deleteMatchStmt, deleteMatch, channelID)
	return err
}

const deleteMatchList = `-- name: DeleteMatchList :exec
DELETE FROM matches WHERE channel_id IN (/*SLICE:channel_id*/?)
`

func (q *Queries) DeleteMatchList(ctx context.Context, channelID []string) error {
	query := deleteMatchList
	var queryParams []interface{}
	if len(channelID) > 0 {
		for _, v := range channelID {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:channel_id*/?", strings.Repeat(",?", len(channelID))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:channel_id*/?", "NULL", 1)
	}
	_, err := q.exec(ctx, nil, query, queryParams...)
	return err
}

const getMatch = `-- name: GetMatch :one
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    event_id,
    scheduled_at,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE channel_id = ?1
`

type GetMatchRow struct {
	GuildID             string `db:"guild_id"`
	ChannelID           string `db:"channel_id"`
	ChannelAccessibleAt int64  `db:"channel_accessible_at"`
	ChannelAccessible   int64  `db:"channel_accessible"`
	ChannelDeleteAt     int64  `db:"channel_delete_at"`
	MessageID           string `db:"message_id"`
	EventID             string `db:"event_id"`
	ScheduledAt         int64  `db:"scheduled_at"`
	CreatedAt           int64  `db:"created_at"`
	CreatedBy           string `db:"created_by"`
	UpdatedAt           int64  `db:"updated_at"`
	UpdatedBy           string `db:"updated_by"`
}

func (q *Queries) GetMatch(ctx context.Context, channelID string) (GetMatchRow, error) {
	row := q.queryRow(ctx, q.getMatchStmt, getMatch, channelID)
	var i GetMatchRow
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.ChannelAccessibleAt,
		&i.ChannelAccessible,
		&i.ChannelDeleteAt,
		&i.MessageID,
		&i.EventID,
		&i.ScheduledAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const listGuildMatches = `-- name: ListGuildMatches :many
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    event_id,
    scheduled_at,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE guild_id = ?1
ORDER BY scheduled_at ASC
`

type ListGuildMatchesRow struct {
	GuildID             string `db:"guild_id"`
	ChannelID           string `db:"channel_id"`
	ChannelAccessibleAt int64  `db:"channel_accessible_at"`
	ChannelAccessible   int64  `db:"channel_accessible"`
	ChannelDeleteAt     int64  `db:"channel_delete_at"`
	MessageID           string `db:"message_id"`
	EventID             string `db:"event_id"`
	ScheduledAt         int64  `db:"scheduled_at"`
	CreatedAt           int64  `db:"created_at"`
	CreatedBy           string `db:"created_by"`
	UpdatedAt           int64  `db:"updated_at"`
	UpdatedBy           string `db:"updated_by"`
}

func (q *Queries) ListGuildMatches(ctx context.Context, guildID string) ([]ListGuildMatchesRow, error) {
	rows, err := q.query(ctx, q.listGuildMatchesStmt, listGuildMatches, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGuildMatchesRow{}
	for rows.Next() {
		var i ListGuildMatchesRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.ChannelAccessibleAt,
			&i.ChannelAccessible,
			&i.ChannelDeleteAt,
			&i.MessageID,
			&i.EventID,
			&i.ScheduledAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNowAccessibleChannels = `-- name: ListNowAccessibleChannels :many
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE matches.channel_accessible = 0
AND matches.channel_accessible_at <= unixepoch('now')
ORDER BY channel_accessible_at ASC
`

type ListNowAccessibleChannelsRow struct {
	GuildID             string `db:"guild_id"`
	ChannelID           string `db:"channel_id"`
	ChannelAccessibleAt int64  `db:"channel_accessible_at"`
	ChannelAccessible   int64  `db:"channel_accessible"`
	ChannelDeleteAt     int64  `db:"channel_delete_at"`
	MessageID           string `db:"message_id"`
	ScheduledAt         int64  `db:"scheduled_at"`
	CreatedAt           int64  `db:"created_at"`
	CreatedBy           string `db:"created_by"`
	UpdatedAt           int64  `db:"updated_at"`
	UpdatedBy           string `db:"updated_by"`
}

func (q *Queries) ListNowAccessibleChannels(ctx context.Context) ([]ListNowAccessibleChannelsRow, error) {
	rows, err := q.query(ctx, q.listNowAccessibleChannelsStmt, listNowAccessibleChannels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListNowAccessibleChannelsRow{}
	for rows.Next() {
		var i ListNowAccessibleChannelsRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.ChannelAccessibleAt,
			&i.ChannelAccessible,
			&i.ChannelDeleteAt,
			&i.MessageID,
			&i.ScheduledAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNowDeletableChannels = `-- name: ListNowDeletableChannels :many
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    event_id,
    scheduled_at,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE matches.channel_delete_at <= unixepoch('now')
ORDER BY channel_delete_at ASC
`

type ListNowDeletableChannelsRow struct {
	GuildID             string `db:"guild_id"`
	ChannelID           string `db:"channel_id"`
	ChannelAccessibleAt int64  `db:"channel_accessible_at"`
	ChannelAccessible   int64  `db:"channel_accessible"`
	ChannelDeleteAt     int64  `db:"channel_delete_at"`
	MessageID           string `db:"message_id"`
	EventID             string `db:"event_id"`
	ScheduledAt         int64  `db:"scheduled_at"`
	CreatedAt           int64  `db:"created_at"`
	CreatedBy           string `db:"created_by"`
	UpdatedAt           int64  `db:"updated_at"`
	UpdatedBy           string `db:"updated_by"`
}

func (q *Queries) ListNowDeletableChannels(ctx context.Context) ([]ListNowDeletableChannelsRow, error) {
	rows, err := q.query(ctx, q.listNowDeletableChannelsStmt, listNowDeletableChannels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListNowDeletableChannelsRow{}
	for rows.Next() {
		var i ListNowDeletableChannelsRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.ChannelAccessibleAt,
			&i.ChannelAccessible,
			&i.ChannelDeleteAt,
			&i.MessageID,
			&i.EventID,
			&i.ScheduledAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rescheduleMatch = `-- name: RescheduleMatch :exec
UPDATE matches
SET
    channel_accessible_at = ?1,
    channel_delete_at = ?2,
    message_id = ?3,
    event_id = ?4,
    scheduled_at = ?5,
    updated_at = ?6,
    updated_by = ?7
WHERE channel_id = ?8
`

type RescheduleMatchParams struct {
	ChannelAccessibleAt int64  `db:"channel_accessible_at"`
	ChannelDeleteAt     int64  `db:"channel_delete_at"`
	MessageID           string `db:"message_id"`
	EventID             string `db:"event_id"`
	ScheduledAt         int64  `db:"scheduled_at"`
	UpdatedAt           int64  `db:"updated_at"`
	UpdatedBy           string `db:"updated_by"`
	ChannelID           string `db:"channel_id"`
}

func (q *Queries) RescheduleMatch(ctx context.Context, arg RescheduleMatchParams) error {
	_, err := q.exec(ctx, q.rescheduleMatchStmt, rescheduleMatch,
		arg.ChannelAccessibleAt,
		arg.ChannelDeleteAt,
		arg.MessageID,
		arg.EventID,
		arg.ScheduledAt,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.ChannelID,
	)
	return err
}

const resetEventID = `-- name: ResetEventID :exec
UPDATE matches
SET
    event_id = ''
WHERE guild_id = ?1
AND event_id = ?2
`

type ResetEventIDParams struct {
	GuildID string `db:"guild_id"`
	EventID string `db:"event_id"`
}

func (q *Queries) ResetEventID(ctx context.Context, arg ResetEventIDParams) error {
	_, err := q.exec(ctx, q.resetEventIDStmt, resetEventID, arg.GuildID, arg.EventID)
	return err
}

const updateMatchChannelAccessibility = `-- name: UpdateMatchChannelAccessibility :exec
UPDATE matches
SET
    channel_accessible = ?1
WHERE channel_id = ?2
`

type UpdateMatchChannelAccessibilityParams struct {
	ChannelAccessible int64  `db:"channel_accessible"`
	ChannelID         string `db:"channel_id"`
}

func (q *Queries) UpdateMatchChannelAccessibility(ctx context.Context, arg UpdateMatchChannelAccessibilityParams) error {
	_, err := q.exec(ctx, q.updateMatchChannelAccessibilityStmt, updateMatchChannelAccessibility, arg.ChannelAccessible, arg.ChannelID)
	return err
}

const updateMatchEventID = `-- name: UpdateMatchEventID :exec
UPDATE matches
SET
    event_id = ?1
WHERE channel_id = ?2
`

type UpdateMatchEventIDParams struct {
	EventID   string `db:"event_id"`
	ChannelID string `db:"channel_id"`
}

func (q *Queries) UpdateMatchEventID(ctx context.Context, arg UpdateMatchEventIDParams) error {
	_, err := q.exec(ctx, q.updateMatchEventIDStmt, updateMatchEventID, arg.EventID, arg.ChannelID)
	return err
}
