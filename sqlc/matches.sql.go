// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: matches.sql

package sqlc

import (
	"context"
)

const addMatch = `-- name: AddMatch :exec
INSERT INTO matches (
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    required_participants_per_team,
    participation_confirmation_until,
    participation_entry_closed,
    created_at,
    created_by,
    updated_at,
    updated_by
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10,
    ?11,
    ?12,
    ?13,
    ?14
)
`

type AddMatchParams struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) AddMatch(ctx context.Context, arg AddMatchParams) error {
	_, err := q.exec(ctx, q.addMatchStmt, addMatch,
		arg.GuildID,
		arg.ChannelID,
		arg.ChannelAccessibleAt,
		arg.ChannelAccessible,
		arg.ChannelDeleteAt,
		arg.MessageID,
		arg.ScheduledAt,
		arg.RequiredParticipantsPerTeam,
		arg.ParticipationConfirmationUntil,
		arg.ParticipationEntryClosed,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	return err
}

const closeParticipationEntry = `-- name: CloseParticipationEntry :exec
UPDATE matches
SET
    participation_entry_closed = 1
WHERE channel_id = ?1
`

func (q *Queries) CloseParticipationEntry(ctx context.Context, channelID string) error {
	_, err := q.exec(ctx, q.closeParticipationEntryStmt, closeParticipationEntry, channelID)
	return err
}

const countMatches = `-- name: CountMatches :one
SELECT COUNT(channel_id) AS count
FROM matches
WHERE guild_id = ?1
`

func (q *Queries) CountMatches(ctx context.Context, guildID string) (int64, error) {
	row := q.queryRow(ctx, q.countMatchesStmt, countMatches, guildID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteGuildMatches = `-- name: DeleteGuildMatches :exec
DELETE FROM matches WHERE guild_id = ?1
`

func (q *Queries) DeleteGuildMatches(ctx context.Context, guildID string) error {
	_, err := q.exec(ctx, q.deleteGuildMatchesStmt, deleteGuildMatches, guildID)
	return err
}

const deleteMatch = `-- name: DeleteMatch :exec
DELETE FROM matches WHERE channel_id = ?1
`

func (q *Queries) DeleteMatch(ctx context.Context, channelID string) error {
	_, err := q.exec(ctx, q.deleteMatchStmt, deleteMatch, channelID)
	return err
}

const getMatch = `-- name: GetMatch :one
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    required_participants_per_team,
    participation_confirmation_until,
    participation_entry_closed,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE channel_id = ?1
`

type GetMatchRow struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) GetMatch(ctx context.Context, channelID string) (GetMatchRow, error) {
	row := q.queryRow(ctx, q.getMatchStmt, getMatch, channelID)
	var i GetMatchRow
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.ChannelAccessibleAt,
		&i.ChannelAccessible,
		&i.ChannelDeleteAt,
		&i.MessageID,
		&i.ScheduledAt,
		&i.RequiredParticipantsPerTeam,
		&i.ParticipationConfirmationUntil,
		&i.ParticipationEntryClosed,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const listGuildMatches = `-- name: ListGuildMatches :many
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    required_participants_per_team,
    participation_confirmation_until,
    participation_entry_closed,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE guild_id = ?1
ORDER BY scheduled_at ASC
`

type ListGuildMatchesRow struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) ListGuildMatches(ctx context.Context, guildID string) ([]ListGuildMatchesRow, error) {
	rows, err := q.query(ctx, q.listGuildMatchesStmt, listGuildMatches, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGuildMatchesRow{}
	for rows.Next() {
		var i ListGuildMatchesRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.ChannelAccessibleAt,
			&i.ChannelAccessible,
			&i.ChannelDeleteAt,
			&i.MessageID,
			&i.ScheduledAt,
			&i.RequiredParticipantsPerTeam,
			&i.ParticipationConfirmationUntil,
			&i.ParticipationEntryClosed,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNowAccessibleChannels = `-- name: ListNowAccessibleChannels :many
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    required_participants_per_team,
    participation_confirmation_until,
    participation_entry_closed,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE matches.channel_accessible = 0
AND matches.channel_accessible_at <= unixepoch('now')
ORDER BY channel_accessible_at ASC
LIMIT 1
`

type ListNowAccessibleChannelsRow struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) ListNowAccessibleChannels(ctx context.Context) ([]ListNowAccessibleChannelsRow, error) {
	rows, err := q.query(ctx, q.listNowAccessibleChannelsStmt, listNowAccessibleChannels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListNowAccessibleChannelsRow{}
	for rows.Next() {
		var i ListNowAccessibleChannelsRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.ChannelAccessibleAt,
			&i.ChannelAccessible,
			&i.ChannelDeleteAt,
			&i.MessageID,
			&i.ScheduledAt,
			&i.RequiredParticipantsPerTeam,
			&i.ParticipationConfirmationUntil,
			&i.ParticipationEntryClosed,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNowDeletableChannels = `-- name: ListNowDeletableChannels :many
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    required_participants_per_team,
    participation_confirmation_until,
    participation_entry_closed,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE matches.channel_delete_at <= unixepoch('now')
ORDER BY channel_delete_at ASC
`

type ListNowDeletableChannelsRow struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) ListNowDeletableChannels(ctx context.Context) ([]ListNowDeletableChannelsRow, error) {
	rows, err := q.query(ctx, q.listNowDeletableChannelsStmt, listNowDeletableChannels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListNowDeletableChannelsRow{}
	for rows.Next() {
		var i ListNowDeletableChannelsRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.ChannelAccessibleAt,
			&i.ChannelAccessible,
			&i.ChannelDeleteAt,
			&i.MessageID,
			&i.ScheduledAt,
			&i.RequiredParticipantsPerTeam,
			&i.ParticipationConfirmationUntil,
			&i.ParticipationEntryClosed,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNowExpiredConfirmationDeadlines = `-- name: ListNowExpiredConfirmationDeadlines :many
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    required_participants_per_team,
    participation_confirmation_until,
    participation_entry_closed,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE matches.participation_confirmation_until <= unixepoch('now')
AND matches.participation_entry_closed = 0
ORDER BY participation_confirmation_until ASC
`

type ListNowExpiredConfirmationDeadlinesRow struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) ListNowExpiredConfirmationDeadlines(ctx context.Context) ([]ListNowExpiredConfirmationDeadlinesRow, error) {
	rows, err := q.query(ctx, q.listNowExpiredConfirmationDeadlinesStmt, listNowExpiredConfirmationDeadlines)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListNowExpiredConfirmationDeadlinesRow{}
	for rows.Next() {
		var i ListNowExpiredConfirmationDeadlinesRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.ChannelAccessibleAt,
			&i.ChannelAccessible,
			&i.ChannelDeleteAt,
			&i.MessageID,
			&i.ScheduledAt,
			&i.RequiredParticipantsPerTeam,
			&i.ParticipationConfirmationUntil,
			&i.ParticipationEntryClosed,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rescheduleMatch = `-- name: RescheduleMatch :exec
UPDATE matches
SET
    channel_accessible_at = ?1,
    channel_delete_at = ?2,
    message_id = ?3,
    scheduled_at = ?4,
    required_participants_per_team = ?5,
    participation_confirmation_until = ?6,
    participation_entry_closed = ?7,
    updated_at = ?8,
    updated_by = ?9
WHERE channel_id = ?10
`

type RescheduleMatchParams struct {
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
	ChannelID                      string `db:"channel_id"`
}

func (q *Queries) RescheduleMatch(ctx context.Context, arg RescheduleMatchParams) error {
	_, err := q.exec(ctx, q.rescheduleMatchStmt, rescheduleMatch,
		arg.ChannelAccessibleAt,
		arg.ChannelDeleteAt,
		arg.MessageID,
		arg.ScheduledAt,
		arg.RequiredParticipantsPerTeam,
		arg.ParticipationConfirmationUntil,
		arg.ParticipationEntryClosed,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.ChannelID,
	)
	return err
}

const updateMatchChannelAccessibility = `-- name: UpdateMatchChannelAccessibility :exec
UPDATE matches
SET
    channel_accessible = ?1
WHERE channel_id = ?2
`

type UpdateMatchChannelAccessibilityParams struct {
	ChannelAccessible int64  `db:"channel_accessible"`
	ChannelID         string `db:"channel_id"`
}

func (q *Queries) UpdateMatchChannelAccessibility(ctx context.Context, arg UpdateMatchChannelAccessibilityParams) error {
	_, err := q.exec(ctx, q.updateMatchChannelAccessibilityStmt, updateMatchChannelAccessibility, arg.ChannelAccessible, arg.ChannelID)
	return err
}
