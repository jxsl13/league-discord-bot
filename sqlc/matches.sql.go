// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: matches.sql

package sqlc

import (
	"context"
)

const addMatch = `-- name: AddMatch :exec
INSERT INTO matches (
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    reminder_count,
    required_participants_per_team,
    participation_confirmation_until,
    created_at,
    created_by,
    updated_at,
    updated_by
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10,
    ?11,
    ?12,
    ?13,
    ?14
)
`

type AddMatchParams struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	ReminderCount                  int64  `db:"reminder_count"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) AddMatch(ctx context.Context, arg AddMatchParams) error {
	_, err := q.exec(ctx, q.addMatchStmt, addMatch,
		arg.GuildID,
		arg.ChannelID,
		arg.ChannelAccessibleAt,
		arg.ChannelAccessible,
		arg.ChannelDeleteAt,
		arg.MessageID,
		arg.ScheduledAt,
		arg.ReminderCount,
		arg.RequiredParticipantsPerTeam,
		arg.ParticipationConfirmationUntil,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	return err
}

const closeParticipationEntry = `-- name: CloseParticipationEntry :exec
UPDATE matches
SET
    participation_entry_closed = 1
WHERE channel_id = ?1
`

func (q *Queries) CloseParticipationEntry(ctx context.Context, channelID string) error {
	_, err := q.exec(ctx, q.closeParticipationEntryStmt, closeParticipationEntry, channelID)
	return err
}

const countMatches = `-- name: CountMatches :one
SELECT COUNT(channel_id) AS count
FROM matches
WHERE guild_id = ?1
`

func (q *Queries) CountMatches(ctx context.Context, guildID string) (int64, error) {
	row := q.queryRow(ctx, q.countMatchesStmt, countMatches, guildID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteGuildMatches = `-- name: DeleteGuildMatches :exec
DELETE FROM matches WHERE guild_id = ?1
`

func (q *Queries) DeleteGuildMatches(ctx context.Context, guildID string) error {
	_, err := q.exec(ctx, q.deleteGuildMatchesStmt, deleteGuildMatches, guildID)
	return err
}

const deleteMatch = `-- name: DeleteMatch :exec
DELETE FROM matches WHERE channel_id = ?1
`

func (q *Queries) DeleteMatch(ctx context.Context, channelID string) error {
	_, err := q.exec(ctx, q.deleteMatchStmt, deleteMatch, channelID)
	return err
}

const getMatch = `-- name: GetMatch :one
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    reminder_count,
    required_participants_per_team,
    participation_confirmation_until,
    participation_entry_closed,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE channel_id = ?1
`

type GetMatchRow struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	ReminderCount                  int64  `db:"reminder_count"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) GetMatch(ctx context.Context, channelID string) (GetMatchRow, error) {
	row := q.queryRow(ctx, q.getMatchStmt, getMatch, channelID)
	var i GetMatchRow
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.ChannelAccessibleAt,
		&i.ChannelAccessible,
		&i.ChannelDeleteAt,
		&i.MessageID,
		&i.ScheduledAt,
		&i.ReminderCount,
		&i.RequiredParticipantsPerTeam,
		&i.ParticipationConfirmationUntil,
		&i.ParticipationEntryClosed,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const listGuildMatches = `-- name: ListGuildMatches :many
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    reminder_count,
    required_participants_per_team,
    participation_confirmation_until,
    participation_entry_closed,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE guild_id = ?1
ORDER BY scheduled_at ASC
`

type ListGuildMatchesRow struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	ReminderCount                  int64  `db:"reminder_count"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) ListGuildMatches(ctx context.Context, guildID string) ([]ListGuildMatchesRow, error) {
	rows, err := q.query(ctx, q.listGuildMatchesStmt, listGuildMatches, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGuildMatchesRow{}
	for rows.Next() {
		var i ListGuildMatchesRow
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.ChannelAccessibleAt,
			&i.ChannelAccessible,
			&i.ChannelDeleteAt,
			&i.MessageID,
			&i.ScheduledAt,
			&i.ReminderCount,
			&i.RequiredParticipantsPerTeam,
			&i.ParticipationConfirmationUntil,
			&i.ParticipationEntryClosed,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nextAccessibleChannel = `-- name: NextAccessibleChannel :one
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    reminder_count,
    required_participants_per_team,
    participation_confirmation_until,
    participation_entry_closed,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE matches.channel_accessible = 0
ORDER BY channel_accessible_at ASC
LIMIT 1
`

type NextAccessibleChannelRow struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	ReminderCount                  int64  `db:"reminder_count"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) NextAccessibleChannel(ctx context.Context) (NextAccessibleChannelRow, error) {
	row := q.queryRow(ctx, q.nextAccessibleChannelStmt, nextAccessibleChannel)
	var i NextAccessibleChannelRow
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.ChannelAccessibleAt,
		&i.ChannelAccessible,
		&i.ChannelDeleteAt,
		&i.MessageID,
		&i.ScheduledAt,
		&i.ReminderCount,
		&i.RequiredParticipantsPerTeam,
		&i.ParticipationConfirmationUntil,
		&i.ParticipationEntryClosed,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const nextMatchChannelDelete = `-- name: NextMatchChannelDelete :one
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    reminder_count,
    required_participants_per_team,
    participation_confirmation_until,
    participation_entry_closed,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE matches.channel_delete_at <= unixepoch('now')
ORDER BY channel_delete_at ASC
LIMIT 1
`

type NextMatchChannelDeleteRow struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	ReminderCount                  int64  `db:"reminder_count"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) NextMatchChannelDelete(ctx context.Context) (NextMatchChannelDeleteRow, error) {
	row := q.queryRow(ctx, q.nextMatchChannelDeleteStmt, nextMatchChannelDelete)
	var i NextMatchChannelDeleteRow
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.ChannelAccessibleAt,
		&i.ChannelAccessible,
		&i.ChannelDeleteAt,
		&i.MessageID,
		&i.ScheduledAt,
		&i.ReminderCount,
		&i.RequiredParticipantsPerTeam,
		&i.ParticipationConfirmationUntil,
		&i.ParticipationEntryClosed,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const nextMatchReminder = `-- name: NextMatchReminder :one
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    reminder_count,
    required_participants_per_team,
    participation_confirmation_until,
    participation_entry_closed,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE matches.scheduled_at >= unixepoch('now')
AND matches.reminder_count <= ?1
ORDER BY scheduled_at ASC
LIMIT 1
`

type NextMatchReminderRow struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	ReminderCount                  int64  `db:"reminder_count"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) NextMatchReminder(ctx context.Context, maxReminderIndex int64) (NextMatchReminderRow, error) {
	row := q.queryRow(ctx, q.nextMatchReminderStmt, nextMatchReminder, maxReminderIndex)
	var i NextMatchReminderRow
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.ChannelAccessibleAt,
		&i.ChannelAccessible,
		&i.ChannelDeleteAt,
		&i.MessageID,
		&i.ScheduledAt,
		&i.ReminderCount,
		&i.RequiredParticipantsPerTeam,
		&i.ParticipationConfirmationUntil,
		&i.ParticipationEntryClosed,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const nextParticipationConfirmationDeadline = `-- name: NextParticipationConfirmationDeadline :one
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    reminder_count,
    required_participants_per_team,
    participation_confirmation_until,
    participation_entry_closed,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE matches.participation_confirmation_until <= unixepoch('now')
AND matches.participation_entry_closed = 0
ORDER BY participation_confirmation_until ASC
LIMIT 1
`

type NextParticipationConfirmationDeadlineRow struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	ReminderCount                  int64  `db:"reminder_count"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) NextParticipationConfirmationDeadline(ctx context.Context) (NextParticipationConfirmationDeadlineRow, error) {
	row := q.queryRow(ctx, q.nextParticipationConfirmationDeadlineStmt, nextParticipationConfirmationDeadline)
	var i NextParticipationConfirmationDeadlineRow
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.ChannelAccessibleAt,
		&i.ChannelAccessible,
		&i.ChannelDeleteAt,
		&i.MessageID,
		&i.ScheduledAt,
		&i.ReminderCount,
		&i.RequiredParticipantsPerTeam,
		&i.ParticipationConfirmationUntil,
		&i.ParticipationEntryClosed,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const nextScheduledMatch = `-- name: NextScheduledMatch :one
SELECT
    guild_id,
    channel_id,
    channel_accessible_at,
    channel_accessible,
    channel_delete_at,
    message_id,
    scheduled_at,
    reminder_count,
    required_participants_per_team,
    participation_confirmation_until,
    participation_entry_closed,
    created_at,
    created_by,
    updated_at,
    updated_by
FROM matches
WHERE matches.scheduled_at > unixepoch('now')
ORDER BY scheduled_at ASC
LIMIT 1
`

type NextScheduledMatchRow struct {
	GuildID                        string `db:"guild_id"`
	ChannelID                      string `db:"channel_id"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelAccessible              int64  `db:"channel_accessible"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	MessageID                      string `db:"message_id"`
	ScheduledAt                    int64  `db:"scheduled_at"`
	ReminderCount                  int64  `db:"reminder_count"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ParticipationEntryClosed       int64  `db:"participation_entry_closed"`
	CreatedAt                      int64  `db:"created_at"`
	CreatedBy                      string `db:"created_by"`
	UpdatedAt                      int64  `db:"updated_at"`
	UpdatedBy                      string `db:"updated_by"`
}

func (q *Queries) NextScheduledMatch(ctx context.Context) (NextScheduledMatchRow, error) {
	row := q.queryRow(ctx, q.nextScheduledMatchStmt, nextScheduledMatch)
	var i NextScheduledMatchRow
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.ChannelAccessibleAt,
		&i.ChannelAccessible,
		&i.ChannelDeleteAt,
		&i.MessageID,
		&i.ScheduledAt,
		&i.ReminderCount,
		&i.RequiredParticipantsPerTeam,
		&i.ParticipationConfirmationUntil,
		&i.ParticipationEntryClosed,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const rescheduleMatch = `-- name: RescheduleMatch :exec
UPDATE matches
SET
    scheduled_at = ?1,
    reminder_count = ?2,
    required_participants_per_team = ?3,
    participation_confirmation_until = ?4,
    participation_entry_closed = 0,
    channel_accessible_at = ?5,
    channel_accessible = 0,
    channel_delete_at = ?6,
    updated_by = ?7
WHERE channel_id = ?8
`

type RescheduleMatchParams struct {
	ScheduledAt                    int64  `db:"scheduled_at"`
	ReminderCount                  int64  `db:"reminder_count"`
	RequiredParticipantsPerTeam    int64  `db:"required_participants_per_team"`
	ParticipationConfirmationUntil int64  `db:"participation_confirmation_until"`
	ChannelAccessibleAt            int64  `db:"channel_accessible_at"`
	ChannelDeleteAt                int64  `db:"channel_delete_at"`
	UpdatedBy                      string `db:"updated_by"`
	ChannelID                      string `db:"channel_id"`
}

func (q *Queries) RescheduleMatch(ctx context.Context, arg RescheduleMatchParams) error {
	_, err := q.exec(ctx, q.rescheduleMatchStmt, rescheduleMatch,
		arg.ScheduledAt,
		arg.ReminderCount,
		arg.RequiredParticipantsPerTeam,
		arg.ParticipationConfirmationUntil,
		arg.ChannelAccessibleAt,
		arg.ChannelDeleteAt,
		arg.UpdatedBy,
		arg.ChannelID,
	)
	return err
}

const resetMatchReminderCount = `-- name: ResetMatchReminderCount :exec
UPDATE matches
SET
    reminder_count = 0
WHERE channel_id = ?1
`

func (q *Queries) ResetMatchReminderCount(ctx context.Context, channelID string) error {
	_, err := q.exec(ctx, q.resetMatchReminderCountStmt, resetMatchReminderCount, channelID)
	return err
}

const updateMatchChannelAccessibility = `-- name: UpdateMatchChannelAccessibility :exec
UPDATE matches
SET
    channel_accessible = ?1
WHERE channel_id = ?2
`

type UpdateMatchChannelAccessibilityParams struct {
	ChannelAccessible int64  `db:"channel_accessible"`
	ChannelID         string `db:"channel_id"`
}

func (q *Queries) UpdateMatchChannelAccessibility(ctx context.Context, arg UpdateMatchChannelAccessibilityParams) error {
	_, err := q.exec(ctx, q.updateMatchChannelAccessibilityStmt, updateMatchChannelAccessibility, arg.ChannelAccessible, arg.ChannelID)
	return err
}

const updateMatchReminderCount = `-- name: UpdateMatchReminderCount :exec
UPDATE matches
SET
    reminder_count = ?1
WHERE channel_id = ?2
`

type UpdateMatchReminderCountParams struct {
	ReminderCount int64  `db:"reminder_count"`
	ChannelID     string `db:"channel_id"`
}

func (q *Queries) UpdateMatchReminderCount(ctx context.Context, arg UpdateMatchReminderCountParams) error {
	_, err := q.exec(ctx, q.updateMatchReminderCountStmt, updateMatchReminderCount, arg.ReminderCount, arg.ChannelID)
	return err
}
