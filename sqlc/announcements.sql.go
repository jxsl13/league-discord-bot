// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: announcements.sql

package sqlc

import (
	"context"
	"strings"
)

const addAnnouncement = `-- name: AddAnnouncement :exec
INSERT OR REPLACE INTO announcements (
    guild_id,
    starts_at,
    ends_at,
    channel_id,
    interval,
    last_announced_at,
    custom_text_before,
    custom_text_after
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8
)
`

type AddAnnouncementParams struct {
	GuildID          string `db:"guild_id"`
	StartsAt         int64  `db:"starts_at"`
	EndsAt           int64  `db:"ends_at"`
	ChannelID        string `db:"channel_id"`
	Interval         int64  `db:"interval"`
	LastAnnouncedAt  int64  `db:"last_announced_at"`
	CustomTextBefore string `db:"custom_text_before"`
	CustomTextAfter  string `db:"custom_text_after"`
}

func (q *Queries) AddAnnouncement(ctx context.Context, arg AddAnnouncementParams) error {
	_, err := q.exec(ctx, q.addAnnouncementStmt, addAnnouncement,
		arg.GuildID,
		arg.StartsAt,
		arg.EndsAt,
		arg.ChannelID,
		arg.Interval,
		arg.LastAnnouncedAt,
		arg.CustomTextBefore,
		arg.CustomTextAfter,
	)
	return err
}

const continueAnnouncement = `-- name: ContinueAnnouncement :exec
UPDATE announcements
SET last_announced_at = (last_announced_at + interval)
WHERE guild_id = ?1
`

func (q *Queries) ContinueAnnouncement(ctx context.Context, guildID string) error {
	_, err := q.exec(ctx, q.continueAnnouncementStmt, continueAnnouncement, guildID)
	return err
}

const continueAnnouncements = `-- name: ContinueAnnouncements :exec
UPDATE announcements
SET last_announced_at = last_announced_at + interval
WHERE guild_id IN (/*SLICE:guild_id*/?)
`

func (q *Queries) ContinueAnnouncements(ctx context.Context, guildID []string) error {
	query := continueAnnouncements
	var queryParams []interface{}
	if len(guildID) > 0 {
		for _, v := range guildID {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:guild_id*/?", strings.Repeat(",?", len(guildID))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:guild_id*/?", "NULL", 1)
	}
	_, err := q.exec(ctx, nil, query, queryParams...)
	return err
}

const countAnnouncements = `-- name: CountAnnouncements :one
SELECT COUNT(*)
FROM announcements
`

func (q *Queries) CountAnnouncements(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countAnnouncementsStmt, countAnnouncements)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteAnnouncement = `-- name: DeleteAnnouncement :exec
DELETE FROM announcements
WHERE guild_id = ?1
`

func (q *Queries) DeleteAnnouncement(ctx context.Context, guildID string) error {
	_, err := q.exec(ctx, q.deleteAnnouncementStmt, deleteAnnouncement, guildID)
	return err
}

const getAnnouncement = `-- name: GetAnnouncement :one
SELECT
    guild_id,
    starts_at,
    ends_at,
    channel_id,
    interval,
    last_announced_at,
    custom_text_before,
    custom_text_after
FROM announcements
WHERE guild_id = ?1
`

func (q *Queries) GetAnnouncement(ctx context.Context, guildID string) (Announcement, error) {
	row := q.queryRow(ctx, q.getAnnouncementStmt, getAnnouncement, guildID)
	var i Announcement
	err := row.Scan(
		&i.GuildID,
		&i.StartsAt,
		&i.EndsAt,
		&i.ChannelID,
		&i.Interval,
		&i.LastAnnouncedAt,
		&i.CustomTextBefore,
		&i.CustomTextAfter,
	)
	return i, err
}

const listNowDueAnnouncements = `-- name: ListNowDueAnnouncements :many
SELECT
    p.guild_id,
    p.starts_at,
    p.ends_at,
    p.channel_id,
    p.interval,
    p.last_announced_at,
    p.custom_text_before,
    p.custom_text_after
FROM guild_config AS g
JOIN announcements AS p
ON g.guild_id = p.guild_id
WHERE g.enabled = 1
AND p.starts_at <= unixepoch('now')
AND p.ends_at >= unixepoch('now')
AND (p.last_announced_at + p.interval) <= unixepoch('now')
ORDER BY (p.last_announced_at + p.interval) ASC
`

func (q *Queries) ListNowDueAnnouncements(ctx context.Context) ([]Announcement, error) {
	rows, err := q.query(ctx, q.listNowDueAnnouncementsStmt, listNowDueAnnouncements)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Announcement{}
	for rows.Next() {
		var i Announcement
		if err := rows.Scan(
			&i.GuildID,
			&i.StartsAt,
			&i.EndsAt,
			&i.ChannelID,
			&i.Interval,
			&i.LastAnnouncedAt,
			&i.CustomTextBefore,
			&i.CustomTextAfter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
